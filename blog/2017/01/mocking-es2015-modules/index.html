<!DOCTYPE html><html lang="en"><head><title>Mocking ES2015 modules - Steven J Hicks</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/static/css/site.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css"></head><body><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-75007713-1', 'auto');
ga('send', 'pageview');</script><nav class="navbar navbar-inverse navbar-fat navbar-default navbar-static-top"><div class="container-fluid"><div class="navbar-header"><a href="/" class="navbar-brand">Steven J Hicks</a><a href="/about" class="navbar-brand">About</a></div></div></nav><div class="container"><h1>Mocking ES2015 modules</h1><div class="timestamp">January 5, 2017</div><article><p>If you&#39;re unit testing code that is using ES2015 modules [<a href="#footnotes">1</a>], you&#39;ll probably point want to mock dependencies at some point. For the most part this is just like mocking things in any code. My tool of choice right now is <a href="https://github.com/jupiter/simple-mock">simple-mock</a>, but there are gajillions of options.</p>
<h3 id="test-induced-damage">Test-induced damage</h3>
<p>There is some test-induced damage that my team has come to accept with simple-mock, and I am guessing it would be an issue with other mocking libraries like it. While simple-mock is great for mocking functions that are properties on exported objects, it seemed difficult to mock standalone/named exported functions from dependencies.</p>
<p>So we found this to be easy: [<a href="#footnotes">2</a>]</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//dependency.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">someAction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//....</span>
    }
}

<span class="hljs-comment">//test.js</span>
<span class="hljs-keyword">import</span> simple <span class="hljs-keyword">from</span> <span class="hljs-string">'simple-mock'</span>;

<span class="hljs-keyword">import</span> dependency <span class="hljs-keyword">from</span> <span class="hljs-string">'./dependency'</span>;

describe(<span class="hljs-string">'feature'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        simple.restore();
    });

    it(<span class="hljs-string">'calls a dependency'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//Arrange</span>
        simple.mock(dependency, <span class="hljs-string">'someAction'</span>);

        <span class="hljs-comment">//Act</span>
        systemUnderTest.execute();

        <span class="hljs-comment">//Assert</span>
        expect(dependency.someAction.callCount).to.equal(<span class="hljs-number">1</span>);
    });
});</code></pre>

<p>But the <code>simple.mock</code> function is looking for an object, and a property on that object. So we found this to be difficult:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//dependency.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAction</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">//....</span>
}

<span class="hljs-comment">//test.js</span>
<span class="hljs-keyword">import</span> simple <span class="hljs-keyword">from</span> <span class="hljs-string">'simple-mock'</span>;

<span class="hljs-comment">// Notice the difference in how we are importing...</span>
<span class="hljs-keyword">import</span> {someAction} <span class="hljs-keyword">from</span> <span class="hljs-string">'./dependency'</span>;

describe(<span class="hljs-string">'feature'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        simple.restore();
    });

    it(<span class="hljs-string">'calls a dependency'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//Arrange</span>
        <span class="hljs-comment">// ¯\_(ツ)_/¯</span>
        <span class="hljs-comment">// How would we mock 'someAction'? It isn't a property on an object.</span>

        <span class="hljs-comment">//Act</span>
        systemUnderTest.execute();

        <span class="hljs-comment">//Assert</span>
        expect(someAction.callCount).to.equal(<span class="hljs-number">1</span>);
    });
});</code></pre>

<p>As a result of our inability to solve this problem, we had accepted that we would always export a default object from our code, with functions on it as properties.</p>
<p>So while we wanted to export something like this:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//dependency.js - the desired way</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAction</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">//....</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">otherAction</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">//...</span>
}</code></pre>

<p>We just always accepted that we would do this:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//dependency.js - the undesired way</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">someAction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//....</span>
    },
    <span class="hljs-attr">otherAction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//...</span>
    }
}</code></pre>

<h3 id="why-does-it-matter-">Why does it matter?</h3>
<p>There&#39;s a reason this was not ideal. Modern bundlers are able to remove the unused exports out of your code, to reduce your bundle size. But code is only removed if it isn&#39;t imported. By exporting a single object with a bunch of functions on it, the entire object must be imported by the calling code.</p>
<p>So in the first example, if your code called <code>someAction</code> but not <code>otherAction</code>, your final bundle would only include <code>someAction</code>. But in the second example, even if you are only ever calling <code>someAction</code>...you are importing the entire object, and therefore the unused <code>otherAction</code>.</p>
<p>In our app, that ends up not being a problem, because we are using all of the code we write. But if we were writing a library, or some code that was intended to be shared by other apps and therefore might not use everything, this would not be cool.</p>
<h3 id="but-there-is-a-better-way-to-import-the-dependency-">But there is a better way to import the dependency.</h3>
<p>Today, we discovered the answer to our problems. The &quot;import * as&quot; syntax allows you to import all exports from a dependency, expanding them onto an object - and therefore allowing you to mock a named/standalone function from your dependency. [<a href="#footnotes">3</a>]</p>
<p>So all that changes is how we import dependencies into our tests:</p>
<pre><code class="hljs javascript"><span class="hljs-comment">//dependency.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAction</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">//....</span>
}

<span class="hljs-comment">//test.js</span>
<span class="hljs-keyword">import</span> simple <span class="hljs-keyword">from</span> <span class="hljs-string">'simple-mock'</span>;

<span class="hljs-comment">//     vvvvvvvvvvvvvvv Notice the difference in how we are importing</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> dependency <span class="hljs-keyword">from</span> <span class="hljs-string">'./dependency'</span>;
<span class="hljs-comment">//     ^^^^^^^^^^^^^^^</span>

describe(<span class="hljs-string">'feature'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    afterEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        simple.restore();
    });

    it(<span class="hljs-string">'calls a dependency'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//Arrange</span>
        <span class="hljs-comment">// and now we can pass simple.mock a property on an object.</span>
        simple.mock(dependency, <span class="hljs-string">'someAction'</span>);

        <span class="hljs-comment">//Act</span>
        systemUnderTest.execute();

        <span class="hljs-comment">//Assert</span>
        expect(dependency.someAction.callCount).to.equal(<span class="hljs-number">1</span>);
    });
});</code></pre>

<p>Hooray, JavaScript! Hooray, mocking! Boo, test-induced damage!</p>
<hr>
<div id="footnotes"></div>

<p>[1] If you aren&#39;t unit testing your JS, you should be! It is not as scary as it sounds. You&#39;ll see great improvements to the quality of your front-end code. As an added bonus, the guilt that you probably feel for not testing your JS will disappear.</p>
<p>[2] <a href="http://mochajs.org/#arrow-functions">Why aren&#39;t you using ES2015 arrow functions in your tests?</a></p>
<p>[3] I ain&#39;t gonna lie, the discovery of this functionality was, as usual, the result of a <a href="http://stackoverflow.com/a/38414160/1585069">stackoverflow search</a> that I definitely tried a long time ago, but must have narrowly missed.</p>
</article><hr><div id="disqus_thread"><script>(function() {
    var d = document, s = d.createElement('script');
    s.src = '//pleepleus88githubio.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script></div><footer class="row"><hr><h6 class="pull-left">&copy; Steven J Hicks 2017.</h6><h6 class="pull-right">I built this site with<a href="http://www.metalsmith.io/">metalsmith.io.</a></h6></footer></div></body></html>